public class yidongxiangmuNote {


    /*


    项目功能：
        pojo:
            用户：姓名，省份证，社区（多对1），地址，用户类型，（一对多）（集合）联系人，节点，公告，咨询
            节点：节点名称，类型，状态，添加时间，使用者（多对一），上传频率
            节点数据：身份证，传感器类型，变化时间，节点值
            联系人：姓名，关联的用户（多对一）
            产品案例：标题，图片，内容，是否显示
            产品介绍：标题，图片，内容，是否显示
            公告：标题，内容，公告类型，外界url，（多对一）发布公告者。发布社区
            定位数据：身份证，经纬度，改变时间
            咨询类型:类型名称，所属社区
            咨询：（多对一）资讯类型，内容，（多对一）咨询用户，（一对多）被提问管理员，时间，是否完成
            社区：社区名，区域名，社区地址，（一对多）用户，公告，资讯类型
            警报数据：身份证，报警类型，报警时数据，报警等级，是否解决
        dao层:



           接口：
           超级管理员：登录
                        首页：所有在线用户信息，获取用户详细信息
                       创建删除查找社区
                       超管公告
                       产品介绍设置（内容，图片（FTP服务器，通过URL））
                       节点
                       管理社区管理员
                       异常

                  普通用户：咨询
                            个人信息修改接口
                            节点
                    社区管理员：异常消息
                                社区节点





        异常处理器：定义一个异常类，参数为异常码和原因。在控制器上添加异常处理方法，注释@exceptionhandler，在程序中可以定义并抛出异常（寻找用户
        返回为空时，可以定义一个异常），异常处理方法会进行处理
        ajax拦截器：主要为处理器处理前的响应头的设置（mh100.com.cn）
        脏话校验器：主要针对一些个人信息脏话的校验
        发送工具：注册时发送短信验证码（通过淘宝大鱼），忘记密码时可以通过邮箱和短信获取验证码（通过sendcloud）
    使用SSM框架时自己的一些改动优化：
        定义一个高复用服务响应对象：状态（成功，失败），失败原因，泛性值（返回的具体值），通过@JsonSerialize (include = JsonSerialize.Inclusion.NON_NULL)只
            在序列化时只返回非空的值，result的构造方法（成功（状态，值），失败（状态，原因，失败对象））
        mybatis的逆向工程（属性，java类型处理器，java模型生成器，XML文件生成器，接口生成器，数据表等配置），通过数据表生成对应的代码（POJO，接口，xml）
        在web.XML文件中配置编码（utf-8）过滤器，防止中文乱码
        对SQL语句的优化，避免索引失效（用户表里的姓名，节点值表中所属的用户身份证,公告表里的社区ID）避免全表扫描
        查询返回结果较多时，采用分页，模糊查询（按姓名模糊查询社区内的用户，模糊查询社区内的所有公告）节点某段时间的数据
        加redis缓存，避免频繁调用不变的数据（缓存（首页）公告，产品介绍，配合spring缓存注解，在service层公告产品方法中@cacheable@cacheput获取修改数据
        缓存数据）
    遇到的问题：
        （1）mybatis级联删除更新的问题，因为之前使用hibernate时在设置级联时可以支持级联更新删除查询，但mybatis主要支持
        级联查询。就是以用户表和联系人表、节点表的级联关系为例，删除一个用户，就要删除对应的联系人，所以就是想到两种方案，
        第一种就是在设计数据表中添加外键和级联更新删除，先删除主表，再删除子表，缺点就是使用外键造成一定的性能开销，不太适合并发量大的场合，第二种就是
        通过业务代码，先处理关联表中数据，在处理主表数据，进行更新删除，比较适合并发量大的场合，互联网应用，虽应用偏向于企业级的管理系统，并发量一般，
        而且级联删除更新操作并不多，采用了外键的方式。
        （2）异常处理时，由于控制层内类较多，如果在每个类内部编写一个异常处理方法会比较繁琐，代码重复较多，
        通过定义一个基本控制器，通过@exceptionhandler注释一个异常处理方法，然后其他控制器继承该基本控制器类，
        （3）横向越权问题：这个问题主要是在通过restlet进行系统接口测试中发现的，因为开始设计的时候只注意到修改密码的用户验证（使用验证码），没有注意到这些问题，
        主要就是在或者更改用户个人信息（数据上传频率，定位，节点信息等）时，因为持久层很多代码都是通过ID进行数据库的操作，所以当传输参数的ID不是当前用户的真实ID时，会出现横向越权。
         解决方式就是在用户登录时将用户ID等信息保存到session，当修改信息时校验传入的参数ID是否为会话中保存的ID，不同则无权限操作，还有



     */
}
